{"id":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","dependencies":[{"name":"C:\\Users\\ADMINWWQ\\Desktop\\threejs\\01-three_basic\\package.json","includedInParent":true,"mtime":1713938217714},{"name":"C:\\Users\\ADMINWWQ\\Desktop\\threejs\\01-three_basic\\node_modules\\three\\package.json","includedInParent":true,"mtime":1713854592536},{"name":"three","loc":{"line":4,"column":7,"index":35},"parent":"C:\\Users\\ADMINWWQ\\Desktop\\threejs\\01-three_basic\\node_modules\\three\\examples\\jsm\\shaders\\VolumeShader.js","resolved":"C:\\Users\\ADMINWWQ\\Desktop\\threejs\\01-three_basic\\node_modules\\three\\build\\three.module.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VolumeRenderShader1 = void 0;\nvar _three = require(\"three\");\n/**\n * Shaders to render 3D volumes using raycasting.\n * The applied techniques are based on similar implementations in the Visvis and Vispy projects.\n * This is not the only approach, therefore it's marked 1.\n */\n\nvar VolumeRenderShader1 = exports.VolumeRenderShader1 = {\n  uniforms: {\n    'u_size': {\n      value: new _three.Vector3(1, 1, 1)\n    },\n    'u_renderstyle': {\n      value: 0\n    },\n    'u_renderthreshold': {\n      value: 0.5\n    },\n    'u_clim': {\n      value: new _three.Vector2(1, 1)\n    },\n    'u_data': {\n      value: null\n    },\n    'u_cmdata': {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */\"\\n\\n\\t\\tvarying vec4 v_nearpos;\\n\\t\\tvarying vec4 v_farpos;\\n\\t\\tvarying vec3 v_position;\\n\\n\\t\\tvoid main() {\\n\\t\\t\\t\\t// Prepare transforms to map to \\\"camera view\\\". See also:\\n\\t\\t\\t\\t// https://threejs.org/docs/#api/renderers/webgl/WebGLProgram\\n\\t\\t\\t\\tmat4 viewtransformf = modelViewMatrix;\\n\\t\\t\\t\\tmat4 viewtransformi = inverse(modelViewMatrix);\\n\\n\\t\\t\\t\\t// Project local vertex coordinate to camera position. Then do a step\\n\\t\\t\\t\\t// backward (in cam coords) to the near clipping plane, and project back. Do\\n\\t\\t\\t\\t// the same for the far clipping plane. This gives us all the information we\\n\\t\\t\\t\\t// need to calculate the ray and truncate it to the viewing cone.\\n\\t\\t\\t\\tvec4 position4 = vec4(position, 1.0);\\n\\t\\t\\t\\tvec4 pos_in_cam = viewtransformf * position4;\\n\\n\\t\\t\\t\\t// Intersection of ray and near clipping plane (z = -1 in clip coords)\\n\\t\\t\\t\\tpos_in_cam.z = -pos_in_cam.w;\\n\\t\\t\\t\\tv_nearpos = viewtransformi * pos_in_cam;\\n\\n\\t\\t\\t\\t// Intersection of ray and far clipping plane (z = +1 in clip coords)\\n\\t\\t\\t\\tpos_in_cam.z = pos_in_cam.w;\\n\\t\\t\\t\\tv_farpos = viewtransformi * pos_in_cam;\\n\\n\\t\\t\\t\\t// Set varyings and output pos\\n\\t\\t\\t\\tv_position = position;\\n\\t\\t\\t\\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;\\n\\t\\t}\",\n  fragmentShader: /* glsl */\"\\n\\n\\t\\t\\t\\tprecision highp float;\\n\\t\\t\\t\\tprecision mediump sampler3D;\\n\\n\\t\\t\\t\\tuniform vec3 u_size;\\n\\t\\t\\t\\tuniform int u_renderstyle;\\n\\t\\t\\t\\tuniform float u_renderthreshold;\\n\\t\\t\\t\\tuniform vec2 u_clim;\\n\\n\\t\\t\\t\\tuniform sampler3D u_data;\\n\\t\\t\\t\\tuniform sampler2D u_cmdata;\\n\\n\\t\\t\\t\\tvarying vec3 v_position;\\n\\t\\t\\t\\tvarying vec4 v_nearpos;\\n\\t\\t\\t\\tvarying vec4 v_farpos;\\n\\n\\t\\t\\t\\t// The maximum distance through our rendering volume is sqrt(3).\\n\\t\\t\\t\\tconst int MAX_STEPS = 887;\\t// 887 for 512^3, 1774 for 1024^3\\n\\t\\t\\t\\tconst int REFINEMENT_STEPS = 4;\\n\\t\\t\\t\\tconst float relative_step_size = 1.0;\\n\\t\\t\\t\\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);\\n\\t\\t\\t\\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);\\n\\t\\t\\t\\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);\\n\\t\\t\\t\\tconst float shininess = 40.0;\\n\\n\\t\\t\\t\\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\\n\\t\\t\\t\\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\\n\\n\\t\\t\\t\\tfloat sample1(vec3 texcoords);\\n\\t\\t\\t\\tvec4 apply_colormap(float val);\\n\\t\\t\\t\\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);\\n\\n\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\t\\t// Normalize clipping plane info\\n\\t\\t\\t\\t\\t\\tvec3 farpos = v_farpos.xyz / v_farpos.w;\\n\\t\\t\\t\\t\\t\\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;\\n\\n\\t\\t\\t\\t\\t\\t// Calculate unit vector pointing in the view direction through this fragment.\\n\\t\\t\\t\\t\\t\\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);\\n\\n\\t\\t\\t\\t\\t\\t// Compute the (negative) distance to the front surface or near clipping plane.\\n\\t\\t\\t\\t\\t\\t// v_position is the back face of the cuboid, so the initial distance calculated in the dot\\n\\t\\t\\t\\t\\t\\t// product below is the distance from near clip plane to the back of the cuboid\\n\\t\\t\\t\\t\\t\\tfloat distance = dot(nearpos - v_position, view_ray);\\n\\t\\t\\t\\t\\t\\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.x - 0.5 - v_position.x) / view_ray.x));\\n\\t\\t\\t\\t\\t\\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.y - 0.5 - v_position.y) / view_ray.y));\\n\\t\\t\\t\\t\\t\\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.z - 0.5 - v_position.z) / view_ray.z));\\n\\n\\t\\t\\t\\t\\t\\t// Now we have the starting position on the front surface\\n\\t\\t\\t\\t\\t\\tvec3 front = v_position + view_ray * distance;\\n\\n\\t\\t\\t\\t\\t\\t// Decide how many steps to take\\n\\t\\t\\t\\t\\t\\tint nsteps = int(-distance / relative_step_size + 0.5);\\n\\t\\t\\t\\t\\t\\tif ( nsteps < 1 )\\n\\t\\t\\t\\t\\t\\t\\t\\tdiscard;\\n\\n\\t\\t\\t\\t\\t\\t// Get starting location and step vector in texture coordinates\\n\\t\\t\\t\\t\\t\\tvec3 step = ((v_position - front) / u_size) / float(nsteps);\\n\\t\\t\\t\\t\\t\\tvec3 start_loc = front / u_size;\\n\\n\\t\\t\\t\\t\\t\\t// For testing: show the number of steps. This helps to establish\\n\\t\\t\\t\\t\\t\\t// whether the rays are correctly oriented\\n\\t\\t\\t\\t\\t\\t//'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);\\n\\t\\t\\t\\t\\t\\t//'return;\\n\\n\\t\\t\\t\\t\\t\\tif (u_renderstyle == 0)\\n\\t\\t\\t\\t\\t\\t\\t\\tcast_mip(start_loc, step, nsteps, view_ray);\\n\\t\\t\\t\\t\\t\\telse if (u_renderstyle == 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tcast_iso(start_loc, step, nsteps, view_ray);\\n\\n\\t\\t\\t\\t\\t\\tif (gl_FragColor.a < 0.05)\\n\\t\\t\\t\\t\\t\\t\\t\\tdiscard;\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tfloat sample1(vec3 texcoords) {\\n\\t\\t\\t\\t\\t\\t/* Sample float value from a 3D texture. Assumes intensity data. */\\n\\t\\t\\t\\t\\t\\treturn texture(u_data, texcoords.xyz).r;\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tvec4 apply_colormap(float val) {\\n\\t\\t\\t\\t\\t\\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);\\n\\t\\t\\t\\t\\t\\treturn texture2D(u_cmdata, vec2(val, 0.5));\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\\n\\n\\t\\t\\t\\t\\t\\tfloat max_val = -1e6;\\n\\t\\t\\t\\t\\t\\tint max_i = 100;\\n\\t\\t\\t\\t\\t\\tvec3 loc = start_loc;\\n\\n\\t\\t\\t\\t\\t\\t// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\\n\\t\\t\\t\\t\\t\\t// non-constant expression. So we use a hard-coded max, and an additional condition\\n\\t\\t\\t\\t\\t\\t// inside the loop.\\n\\t\\t\\t\\t\\t\\tfor (int iter=0; iter<MAX_STEPS; iter++) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (iter >= nsteps)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t// Sample from the 3D texture\\n\\t\\t\\t\\t\\t\\t\\t\\tfloat val = sample1(loc);\\n\\t\\t\\t\\t\\t\\t\\t\\t// Apply MIP operation\\n\\t\\t\\t\\t\\t\\t\\t\\tif (val > max_val) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmax_val = val;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmax_i = iter;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t// Advance location deeper into the volume\\n\\t\\t\\t\\t\\t\\t\\t\\tloc += step;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Refine location, gives crispier images\\n\\t\\t\\t\\t\\t\\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);\\n\\t\\t\\t\\t\\t\\tvec3 istep = step / float(REFINEMENT_STEPS);\\n\\t\\t\\t\\t\\t\\tfor (int i=0; i<REFINEMENT_STEPS; i++) {\\n\\t\\t\\t\\t\\t\\t\\t\\tmax_val = max(max_val, sample1(iloc));\\n\\t\\t\\t\\t\\t\\t\\t\\tiloc += istep;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Resolve final color\\n\\t\\t\\t\\t\\t\\tgl_FragColor = apply_colormap(max_val);\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\\n\\n\\t\\t\\t\\t\\t\\tgl_FragColor = vec4(0.0);\\t// init transparent\\n\\t\\t\\t\\t\\t\\tvec4 color3 = vec4(0.0);\\t// final color\\n\\t\\t\\t\\t\\t\\tvec3 dstep = 1.5 / u_size;\\t// step to sample derivative\\n\\t\\t\\t\\t\\t\\tvec3 loc = start_loc;\\n\\n\\t\\t\\t\\t\\t\\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);\\n\\n\\t\\t\\t\\t\\t\\t// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\\n\\t\\t\\t\\t\\t\\t// non-constant expression. So we use a hard-coded max, and an additional condition\\n\\t\\t\\t\\t\\t\\t// inside the loop.\\n\\t\\t\\t\\t\\t\\tfor (int iter=0; iter<MAX_STEPS; iter++) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (iter >= nsteps)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Sample from the 3D texture\\n\\t\\t\\t\\t\\t\\t\\t\\tfloat val = sample1(loc);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (val > low_threshold) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Take the last interval in smaller steps\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvec3 iloc = loc - 0.5 * step;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvec3 istep = step / float(REFINEMENT_STEPS);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfor (int i=0; i<REFINEMENT_STEPS; i++) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tval = sample1(iloc);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (val > u_renderthreshold) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tiloc += istep;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Advance location deeper into the volume\\n\\t\\t\\t\\t\\t\\t\\t\\tloc += step;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// Calculate color by incorporating lighting\\n\\n\\t\\t\\t\\t\\t\\t// View direction\\n\\t\\t\\t\\t\\t\\tvec3 V = normalize(view_ray);\\n\\n\\t\\t\\t\\t\\t\\t// calculate normal vector from gradient\\n\\t\\t\\t\\t\\t\\tvec3 N;\\n\\t\\t\\t\\t\\t\\tfloat val1, val2;\\n\\t\\t\\t\\t\\t\\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));\\n\\t\\t\\t\\t\\t\\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));\\n\\t\\t\\t\\t\\t\\tN[0] = val1 - val2;\\n\\t\\t\\t\\t\\t\\tval = max(max(val1, val2), val);\\n\\t\\t\\t\\t\\t\\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));\\n\\t\\t\\t\\t\\t\\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));\\n\\t\\t\\t\\t\\t\\tN[1] = val1 - val2;\\n\\t\\t\\t\\t\\t\\tval = max(max(val1, val2), val);\\n\\t\\t\\t\\t\\t\\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));\\n\\t\\t\\t\\t\\t\\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));\\n\\t\\t\\t\\t\\t\\tN[2] = val1 - val2;\\n\\t\\t\\t\\t\\t\\tval = max(max(val1, val2), val);\\n\\n\\t\\t\\t\\t\\t\\tfloat gm = length(N); // gradient magnitude\\n\\t\\t\\t\\t\\t\\tN = normalize(N);\\n\\n\\t\\t\\t\\t\\t\\t// Flip normal so it points towards viewer\\n\\t\\t\\t\\t\\t\\tfloat Nselect = float(dot(N, V) > 0.0);\\n\\t\\t\\t\\t\\t\\tN = (2.0 * Nselect - 1.0) * N;\\t// ==\\tNselect * N - (1.0-Nselect)*N;\\n\\n\\t\\t\\t\\t\\t\\t// Init colors\\n\\t\\t\\t\\t\\t\\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);\\n\\t\\t\\t\\t\\t\\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);\\n\\t\\t\\t\\t\\t\\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);\\n\\n\\t\\t\\t\\t\\t\\t// note: could allow multiple lights\\n\\t\\t\\t\\t\\t\\tfor (int i=0; i<1; i++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t // Get light direction (make sure to prevent zero devision)\\n\\t\\t\\t\\t\\t\\t\\t\\tvec3 L = normalize(view_ray);\\t//lightDirs[i];\\n\\t\\t\\t\\t\\t\\t\\t\\tfloat lightEnabled = float( length(L) > 0.0 );\\n\\t\\t\\t\\t\\t\\t\\t\\tL = normalize(L + (1.0 - lightEnabled));\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Calculate lighting properties\\n\\t\\t\\t\\t\\t\\t\\t\\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);\\n\\t\\t\\t\\t\\t\\t\\t\\tvec3 H = normalize(L+V); // Halfway vector\\n\\t\\t\\t\\t\\t\\t\\t\\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Calculate mask\\n\\t\\t\\t\\t\\t\\t\\t\\tfloat mask1 = lightEnabled;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Calculate colors\\n\\t\\t\\t\\t\\t\\t\\t\\tambient_color +=\\tmask1 * ambient_color;\\t// * gl_LightSource[i].ambient;\\n\\t\\t\\t\\t\\t\\t\\t\\tdiffuse_color +=\\tmask1 * lambertTerm;\\n\\t\\t\\t\\t\\t\\t\\t\\tspecular_color += mask1 * specularTerm * specular_color;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Calculate final color by componing different components\\n\\t\\t\\t\\t\\t\\tvec4 final_color;\\n\\t\\t\\t\\t\\t\\tvec4 color = apply_colormap(val);\\n\\t\\t\\t\\t\\t\\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;\\n\\t\\t\\t\\t\\t\\tfinal_color.a = color.a;\\n\\t\\t\\t\\t\\t\\treturn final_color;\\n\\t\\t\\t\\t}\"\n};"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":1,"column":0}},{"generated":{"line":7,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":1,"column":0},"name":"_three"},{"generated":{"line":7,"column":10},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":1,"column":0}},{"generated":{"line":7,"column":13},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":1,"column":0},"name":"require"},{"generated":{"line":7,"column":20},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":0},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":6,"column":0}},{"generated":{"line":9,"column":0},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":7,"column":0}},{"generated":{"line":10,"column":0},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":8,"column":0}},{"generated":{"line":11,"column":0},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":9,"column":0}},{"generated":{"line":12,"column":0},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":10,"column":0}},{"generated":{"line":14,"column":0},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":12,"column":0}},{"generated":{"line":14,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":12,"column":6},"name":"VolumeRenderShader1"},{"generated":{"line":14,"column":23},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":12,"column":25}},{"generated":{"line":14,"column":26},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":12,"column":25},"name":"exports"},{"generated":{"line":14,"column":33},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":12,"column":25}},{"generated":{"line":14,"column":34},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":12,"column":25},"name":"VolumeRenderShader1"},{"generated":{"line":14,"column":53},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":12,"column":25}},{"generated":{"line":14,"column":56},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":12,"column":28}},{"generated":{"line":15,"column":2},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":14,"column":1},"name":"uniforms"},{"generated":{"line":15,"column":10},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":14,"column":9}},{"generated":{"line":15,"column":12},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":14,"column":11}},{"generated":{"line":16,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":2}},{"generated":{"line":16,"column":12},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":10}},{"generated":{"line":16,"column":14},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":12}},{"generated":{"line":17,"column":6},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":14},"name":"value"},{"generated":{"line":17,"column":11},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":19}},{"generated":{"line":17,"column":13},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":21}},{"generated":{"line":17,"column":17},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":25},"name":"Vector3"},{"generated":{"line":17,"column":31},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":32}},{"generated":{"line":17,"column":32},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":34}},{"generated":{"line":17,"column":33},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":35}},{"generated":{"line":17,"column":35},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":37}},{"generated":{"line":17,"column":36},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":38}},{"generated":{"line":17,"column":38},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":40}},{"generated":{"line":17,"column":39},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":42}},{"generated":{"line":18,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":44}},{"generated":{"line":18,"column":5},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":15,"column":45}},{"generated":{"line":19,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":16,"column":2}},{"generated":{"line":19,"column":19},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":16,"column":17}},{"generated":{"line":19,"column":21},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":16,"column":19}},{"generated":{"line":20,"column":6},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":16,"column":21},"name":"value"},{"generated":{"line":20,"column":11},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":16,"column":26}},{"generated":{"line":20,"column":13},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":16,"column":28}},{"generated":{"line":21,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":16,"column":30}},{"generated":{"line":21,"column":5},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":16,"column":31}},{"generated":{"line":22,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":17,"column":2}},{"generated":{"line":22,"column":23},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":17,"column":21}},{"generated":{"line":22,"column":25},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":17,"column":23}},{"generated":{"line":23,"column":6},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":17,"column":25},"name":"value"},{"generated":{"line":23,"column":11},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":17,"column":30}},{"generated":{"line":23,"column":13},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":17,"column":32}},{"generated":{"line":24,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":17,"column":36}},{"generated":{"line":24,"column":5},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":17,"column":37}},{"generated":{"line":25,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":2}},{"generated":{"line":25,"column":12},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":10}},{"generated":{"line":25,"column":14},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":12}},{"generated":{"line":26,"column":6},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":14},"name":"value"},{"generated":{"line":26,"column":11},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":19}},{"generated":{"line":26,"column":13},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":21}},{"generated":{"line":26,"column":17},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":25},"name":"Vector2"},{"generated":{"line":26,"column":31},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":32}},{"generated":{"line":26,"column":32},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":34}},{"generated":{"line":26,"column":33},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":35}},{"generated":{"line":26,"column":35},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":37}},{"generated":{"line":26,"column":36},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":39}},{"generated":{"line":27,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":41}},{"generated":{"line":27,"column":5},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":18,"column":42}},{"generated":{"line":28,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":19,"column":2}},{"generated":{"line":28,"column":12},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":19,"column":10}},{"generated":{"line":28,"column":14},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":19,"column":12}},{"generated":{"line":29,"column":6},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":19,"column":14},"name":"value"},{"generated":{"line":29,"column":11},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":19,"column":19}},{"generated":{"line":29,"column":13},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":19,"column":21}},{"generated":{"line":30,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":19,"column":26}},{"generated":{"line":30,"column":5},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":19,"column":27}},{"generated":{"line":31,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":20,"column":2}},{"generated":{"line":31,"column":14},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":20,"column":12}},{"generated":{"line":31,"column":16},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":20,"column":14}},{"generated":{"line":32,"column":6},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":20,"column":16},"name":"value"},{"generated":{"line":32,"column":11},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":20,"column":21}},{"generated":{"line":32,"column":13},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":20,"column":23}},{"generated":{"line":33,"column":4},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":20,"column":28}},{"generated":{"line":34,"column":2},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":21,"column":1}},{"generated":{"line":34,"column":3},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":21,"column":2}},{"generated":{"line":35,"column":2},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":23,"column":1},"name":"vertexShader"},{"generated":{"line":35,"column":14},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":23,"column":13}},{"generated":{"line":35,"column":16},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":23,"column":15}},{"generated":{"line":35,"column":1312},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":53,"column":4}},{"generated":{"line":36,"column":2},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":55,"column":1},"name":"fragmentShader"},{"generated":{"line":36,"column":16},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":55,"column":15}},{"generated":{"line":36,"column":18},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":55,"column":17}},{"generated":{"line":37,"column":0},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":287,"column":0}},{"generated":{"line":37,"column":1},"source":"../node_modules/three/examples/jsm/shaders/VolumeShader.js","original":{"line":287,"column":1}}],"sources":{"../node_modules/three/examples/jsm/shaders/VolumeShader.js":"import {\n\tVector2,\n\tVector3\n} from 'three';\n\n/**\n * Shaders to render 3D volumes using raycasting.\n * The applied techniques are based on similar implementations in the Visvis and Vispy projects.\n * This is not the only approach, therefore it's marked 1.\n */\n\nconst VolumeRenderShader1 = {\n\n\tuniforms: {\n\t\t'u_size': { value: new Vector3( 1, 1, 1 ) },\n\t\t'u_renderstyle': { value: 0 },\n\t\t'u_renderthreshold': { value: 0.5 },\n\t\t'u_clim': { value: new Vector2( 1, 1 ) },\n\t\t'u_data': { value: null },\n\t\t'u_cmdata': { value: null }\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec4 v_nearpos;\n\t\tvarying vec4 v_farpos;\n\t\tvarying vec3 v_position;\n\n\t\tvoid main() {\n\t\t\t\t// Prepare transforms to map to \"camera view\". See also:\n\t\t\t\t// https://threejs.org/docs/#api/renderers/webgl/WebGLProgram\n\t\t\t\tmat4 viewtransformf = modelViewMatrix;\n\t\t\t\tmat4 viewtransformi = inverse(modelViewMatrix);\n\n\t\t\t\t// Project local vertex coordinate to camera position. Then do a step\n\t\t\t\t// backward (in cam coords) to the near clipping plane, and project back. Do\n\t\t\t\t// the same for the far clipping plane. This gives us all the information we\n\t\t\t\t// need to calculate the ray and truncate it to the viewing cone.\n\t\t\t\tvec4 position4 = vec4(position, 1.0);\n\t\t\t\tvec4 pos_in_cam = viewtransformf * position4;\n\n\t\t\t\t// Intersection of ray and near clipping plane (z = -1 in clip coords)\n\t\t\t\tpos_in_cam.z = -pos_in_cam.w;\n\t\t\t\tv_nearpos = viewtransformi * pos_in_cam;\n\n\t\t\t\t// Intersection of ray and far clipping plane (z = +1 in clip coords)\n\t\t\t\tpos_in_cam.z = pos_in_cam.w;\n\t\t\t\tv_farpos = viewtransformi * pos_in_cam;\n\n\t\t\t\t// Set varyings and output pos\n\t\t\t\tv_position = position;\n\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\t\t\t\tprecision mediump sampler3D;\n\n\t\t\t\tuniform vec3 u_size;\n\t\t\t\tuniform int u_renderstyle;\n\t\t\t\tuniform float u_renderthreshold;\n\t\t\t\tuniform vec2 u_clim;\n\n\t\t\t\tuniform sampler3D u_data;\n\t\t\t\tuniform sampler2D u_cmdata;\n\n\t\t\t\tvarying vec3 v_position;\n\t\t\t\tvarying vec4 v_nearpos;\n\t\t\t\tvarying vec4 v_farpos;\n\n\t\t\t\t// The maximum distance through our rendering volume is sqrt(3).\n\t\t\t\tconst int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3\n\t\t\t\tconst int REFINEMENT_STEPS = 4;\n\t\t\t\tconst float relative_step_size = 1.0;\n\t\t\t\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);\n\t\t\t\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);\n\t\t\t\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);\n\t\t\t\tconst float shininess = 40.0;\n\n\t\t\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\n\t\t\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\n\n\t\t\t\tfloat sample1(vec3 texcoords);\n\t\t\t\tvec4 apply_colormap(float val);\n\t\t\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);\n\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\t// Normalize clipping plane info\n\t\t\t\t\t\tvec3 farpos = v_farpos.xyz / v_farpos.w;\n\t\t\t\t\t\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;\n\n\t\t\t\t\t\t// Calculate unit vector pointing in the view direction through this fragment.\n\t\t\t\t\t\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);\n\n\t\t\t\t\t\t// Compute the (negative) distance to the front surface or near clipping plane.\n\t\t\t\t\t\t// v_position is the back face of the cuboid, so the initial distance calculated in the dot\n\t\t\t\t\t\t// product below is the distance from near clip plane to the back of the cuboid\n\t\t\t\t\t\tfloat distance = dot(nearpos - v_position, view_ray);\n\t\t\t\t\t\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.x - 0.5 - v_position.x) / view_ray.x));\n\t\t\t\t\t\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.y - 0.5 - v_position.y) / view_ray.y));\n\t\t\t\t\t\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.z - 0.5 - v_position.z) / view_ray.z));\n\n\t\t\t\t\t\t// Now we have the starting position on the front surface\n\t\t\t\t\t\tvec3 front = v_position + view_ray * distance;\n\n\t\t\t\t\t\t// Decide how many steps to take\n\t\t\t\t\t\tint nsteps = int(-distance / relative_step_size + 0.5);\n\t\t\t\t\t\tif ( nsteps < 1 )\n\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t// Get starting location and step vector in texture coordinates\n\t\t\t\t\t\tvec3 step = ((v_position - front) / u_size) / float(nsteps);\n\t\t\t\t\t\tvec3 start_loc = front / u_size;\n\n\t\t\t\t\t\t// For testing: show the number of steps. This helps to establish\n\t\t\t\t\t\t// whether the rays are correctly oriented\n\t\t\t\t\t\t//'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);\n\t\t\t\t\t\t//'return;\n\n\t\t\t\t\t\tif (u_renderstyle == 0)\n\t\t\t\t\t\t\t\tcast_mip(start_loc, step, nsteps, view_ray);\n\t\t\t\t\t\telse if (u_renderstyle == 1)\n\t\t\t\t\t\t\t\tcast_iso(start_loc, step, nsteps, view_ray);\n\n\t\t\t\t\t\tif (gl_FragColor.a < 0.05)\n\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t}\n\n\n\t\t\t\tfloat sample1(vec3 texcoords) {\n\t\t\t\t\t\t/* Sample float value from a 3D texture. Assumes intensity data. */\n\t\t\t\t\t\treturn texture(u_data, texcoords.xyz).r;\n\t\t\t\t}\n\n\n\t\t\t\tvec4 apply_colormap(float val) {\n\t\t\t\t\t\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);\n\t\t\t\t\t\treturn texture2D(u_cmdata, vec2(val, 0.5));\n\t\t\t\t}\n\n\n\t\t\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\n\n\t\t\t\t\t\tfloat max_val = -1e6;\n\t\t\t\t\t\tint max_i = 100;\n\t\t\t\t\t\tvec3 loc = start_loc;\n\n\t\t\t\t\t\t// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n\t\t\t\t\t\t// non-constant expression. So we use a hard-coded max, and an additional condition\n\t\t\t\t\t\t// inside the loop.\n\t\t\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {\n\t\t\t\t\t\t\t\tif (iter >= nsteps)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t// Sample from the 3D texture\n\t\t\t\t\t\t\t\tfloat val = sample1(loc);\n\t\t\t\t\t\t\t\t// Apply MIP operation\n\t\t\t\t\t\t\t\tif (val > max_val) {\n\t\t\t\t\t\t\t\t\t\tmax_val = val;\n\t\t\t\t\t\t\t\t\t\tmax_i = iter;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Advance location deeper into the volume\n\t\t\t\t\t\t\t\tloc += step;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Refine location, gives crispier images\n\t\t\t\t\t\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);\n\t\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);\n\t\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {\n\t\t\t\t\t\t\t\tmax_val = max(max_val, sample1(iloc));\n\t\t\t\t\t\t\t\tiloc += istep;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Resolve final color\n\t\t\t\t\t\tgl_FragColor = apply_colormap(max_val);\n\t\t\t\t}\n\n\n\t\t\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\n\n\t\t\t\t\t\tgl_FragColor = vec4(0.0);\t// init transparent\n\t\t\t\t\t\tvec4 color3 = vec4(0.0);\t// final color\n\t\t\t\t\t\tvec3 dstep = 1.5 / u_size;\t// step to sample derivative\n\t\t\t\t\t\tvec3 loc = start_loc;\n\n\t\t\t\t\t\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);\n\n\t\t\t\t\t\t// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n\t\t\t\t\t\t// non-constant expression. So we use a hard-coded max, and an additional condition\n\t\t\t\t\t\t// inside the loop.\n\t\t\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {\n\t\t\t\t\t\t\t\tif (iter >= nsteps)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// Sample from the 3D texture\n\t\t\t\t\t\t\t\tfloat val = sample1(loc);\n\n\t\t\t\t\t\t\t\tif (val > low_threshold) {\n\t\t\t\t\t\t\t\t\t\t// Take the last interval in smaller steps\n\t\t\t\t\t\t\t\t\t\tvec3 iloc = loc - 0.5 * step;\n\t\t\t\t\t\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);\n\t\t\t\t\t\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\tval = sample1(iloc);\n\t\t\t\t\t\t\t\t\t\t\t\tif (val > u_renderthreshold) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tiloc += istep;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Advance location deeper into the volume\n\t\t\t\t\t\t\t\tloc += step;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)\n\t\t\t\t{\n\t\t\t\t\t// Calculate color by incorporating lighting\n\n\t\t\t\t\t\t// View direction\n\t\t\t\t\t\tvec3 V = normalize(view_ray);\n\n\t\t\t\t\t\t// calculate normal vector from gradient\n\t\t\t\t\t\tvec3 N;\n\t\t\t\t\t\tfloat val1, val2;\n\t\t\t\t\t\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));\n\t\t\t\t\t\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));\n\t\t\t\t\t\tN[0] = val1 - val2;\n\t\t\t\t\t\tval = max(max(val1, val2), val);\n\t\t\t\t\t\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));\n\t\t\t\t\t\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));\n\t\t\t\t\t\tN[1] = val1 - val2;\n\t\t\t\t\t\tval = max(max(val1, val2), val);\n\t\t\t\t\t\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));\n\t\t\t\t\t\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));\n\t\t\t\t\t\tN[2] = val1 - val2;\n\t\t\t\t\t\tval = max(max(val1, val2), val);\n\n\t\t\t\t\t\tfloat gm = length(N); // gradient magnitude\n\t\t\t\t\t\tN = normalize(N);\n\n\t\t\t\t\t\t// Flip normal so it points towards viewer\n\t\t\t\t\t\tfloat Nselect = float(dot(N, V) > 0.0);\n\t\t\t\t\t\tN = (2.0 * Nselect - 1.0) * N;\t// ==\tNselect * N - (1.0-Nselect)*N;\n\n\t\t\t\t\t\t// Init colors\n\t\t\t\t\t\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\t\t\t\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\t\t\t\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);\n\n\t\t\t\t\t\t// note: could allow multiple lights\n\t\t\t\t\t\tfor (int i=0; i<1; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t // Get light direction (make sure to prevent zero devision)\n\t\t\t\t\t\t\t\tvec3 L = normalize(view_ray);\t//lightDirs[i];\n\t\t\t\t\t\t\t\tfloat lightEnabled = float( length(L) > 0.0 );\n\t\t\t\t\t\t\t\tL = normalize(L + (1.0 - lightEnabled));\n\n\t\t\t\t\t\t\t\t// Calculate lighting properties\n\t\t\t\t\t\t\t\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);\n\t\t\t\t\t\t\t\tvec3 H = normalize(L+V); // Halfway vector\n\t\t\t\t\t\t\t\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);\n\n\t\t\t\t\t\t\t\t// Calculate mask\n\t\t\t\t\t\t\t\tfloat mask1 = lightEnabled;\n\n\t\t\t\t\t\t\t\t// Calculate colors\n\t\t\t\t\t\t\t\tambient_color +=\tmask1 * ambient_color;\t// * gl_LightSource[i].ambient;\n\t\t\t\t\t\t\t\tdiffuse_color +=\tmask1 * lambertTerm;\n\t\t\t\t\t\t\t\tspecular_color += mask1 * specularTerm * specular_color;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Calculate final color by componing different components\n\t\t\t\t\t\tvec4 final_color;\n\t\t\t\t\t\tvec4 color = apply_colormap(val);\n\t\t\t\t\t\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;\n\t\t\t\t\t\tfinal_color.a = color.a;\n\t\t\t\t\t\treturn final_color;\n\t\t\t\t}`\n\n};\n\nexport { VolumeRenderShader1 };\n"},"lineCount":null}},"error":null,"hash":"a37a9d746068a469809c15b50ef58942","cacheData":{"env":{}}}