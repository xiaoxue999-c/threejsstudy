{"id":"../node_modules/three/examples/jsm/csm/CSMShader.js","dependencies":[{"name":"C:\\Users\\ADMINWWQ\\Desktop\\threejs\\01-three_basic\\package.json","includedInParent":true,"mtime":1713938217714},{"name":"C:\\Users\\ADMINWWQ\\Desktop\\threejs\\01-three_basic\\node_modules\\three\\package.json","includedInParent":true,"mtime":1713854592536},{"name":"three","loc":{"line":1,"column":28,"index":28},"parent":"C:\\Users\\ADMINWWQ\\Desktop\\threejs\\01-three_basic\\node_modules\\three\\examples\\jsm\\csm\\CSMShader.js","resolved":"C:\\Users\\ADMINWWQ\\Desktop\\threejs\\01-three_basic\\node_modules\\three\\build\\three.module.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CSMShader = void 0;\nvar _three = require(\"three\");\nvar CSMShader = exports.CSMShader = {\n  lights_fragment_begin: /* glsl */\"\\nvec3 geometryPosition = - vViewPosition;\\nvec3 geometryNormal = normal;\\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n\\nvec3 geometryClearcoatNormal = vec3( 0.0 );\\n\\n#ifdef USE_CLEARCOAT\\n\\n\\tgeometryClearcoatNormal = clearcoatNormal;\\n\\n#endif\\n\\n#ifdef USE_IRIDESCENCE\\n\\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\\n\\tif ( material.iridescenceThickness == 0.0 ) {\\n\\t\\tmaterial.iridescence = 0.0;\\n\\t} else {\\n\\t\\tmaterial.iridescence = saturate( material.iridescence );\\n\\t}\\n\\tif ( material.iridescence > 0.0 ) {\\n\\t\\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\\n\\t\\t// Iridescence F0 approximation\\n\\t\\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\\n\\t}\\n#endif\\n\\nIncidentLight directLight;\\n\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\tpointLight = pointLights[ i ];\\n\\n\\t\\tgetPointLightInfo( pointLight, geometryPosition, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\n\\tSpotLight spotLight;\\n \\tvec4 spotColor;\\n\\tvec3 spotLightCoord;\\n\\tbool inSpotLightMap;\\n\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\n\\t\\tspotLight = spotLights[ i ];\\n\\n\\t\\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\\n\\n  \\t\\t// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]\\n\\t\\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\\n\\t\\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\\n\\t\\t#else\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\\t\\t#endif\\n\\t\\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\\n\\t\\t\\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\\n\\t\\t\\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\\n\\t\\t\\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\\n\\t\\t\\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\\n\\t\\t#endif\\n\\t\\t#undef SPOT_LIGHT_MAP_INDEX\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\\n\\n\\tDirectionalLight directionalLight;\\n\\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\n\\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\\n\\t\\tvec2 cascade;\\n\\t\\tfloat cascadeCenter;\\n\\t\\tfloat closestEdge;\\n\\t\\tfloat margin;\\n\\t\\tfloat csmx;\\n\\t\\tfloat csmy;\\n\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\t\\tgetDirectionalLightInfo( directionalLight, directLight );\\n\\n\\t\\t\\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\t\\t\\t// NOTE: Depth gets larger away from the camera.\\n\\t\\t\\t\\t// cascade.x is closer, cascade.y is further\\n\\t\\t\\t\\tcascade = CSM_cascades[ i ];\\n\\t\\t\\t\\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\\n\\t\\t\\t\\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\\n\\t\\t\\t\\tmargin = 0.25 * pow( closestEdge, 2.0 );\\n\\t\\t\\t\\tcsmx = cascade.x - margin / 2.0;\\n\\t\\t\\t\\tcsmy = cascade.y + margin / 2.0;\\n\\t\\t\\t\\tif( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\\n\\n\\t\\t\\t\\t\\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\\n\\t\\t\\t\\t\\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\\n\\n\\t\\t\\t\\t\\tvec3 prevColor = directLight.color;\\n\\t\\t\\t\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\t\\t\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\n\\t\\t\\t\\t\\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\\n\\t\\t\\t\\t\\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\\n\\n\\t\\t\\t\\t\\tReflectedLight prevLight = reflectedLight;\\n\\t\\t\\t\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\n\\t\\t\\t\\t\\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\\n\\t\\t\\t\\t\\tfloat blendRatio = shouldBlend ? ratio : 1.0;\\n\\n\\t\\t\\t\\t\\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\\n\\t\\t\\t\\t\\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\\n\\t\\t\\t\\t\\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\\n\\t\\t\\t\\t\\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t#endif\\n\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#elif defined (USE_SHADOWMAP)\\n\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\t\\tgetDirectionalLightInfo( directionalLight, directLight );\\n\\n\\t\\t\\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\n\\t\\t\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\t\\t\\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\n\\t\\t\\t\\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\n\\t#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )\\n\\t\\t// note: no loop here - all CSM lights are in fact one light only\\n\\t\\tgetDirectionalLightInfo( directionalLights[0], directLight );\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\n\\t#endif\\n\\n\\t#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)\\n\\t\\t// compute the lights not casting shadows (if any)\\n\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\t\\tdirectionalLight = directionalLights[ i ];\\n\\n\\t\\t\\tgetDirectionalLightInfo( directionalLight, directLight );\\n\\n\\t\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\n\\t#endif\\n\\n#endif\\n\\n\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\\n\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\n\\t\\tgetDirectionalLightInfo( directionalLight, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\n\\tRectAreaLight rectAreaLight;\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if defined( RE_IndirectDiffuse )\\n\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\n\\t#if defined( USE_LIGHT_PROBES )\\n\\n\\t\\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\\n\\n\\t#endif\\n\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\\n\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\n\\t#endif\\n\\n#endif\\n\\n#if defined( RE_IndirectSpecular )\\n\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n\\n#endif\\n\",\n  lights_pars_begin: /* glsl */\"\\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\\nuniform vec2 CSM_cascades[CSM_CASCADES];\\nuniform float cameraNear;\\nuniform float shadowFar;\\n#endif\\n\\t\" + _three.ShaderChunk.lights_pars_begin\n};"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":1,"column":0}},{"generated":{"line":7,"column":4},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":1,"column":0},"name":"_three"},{"generated":{"line":7,"column":10},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":1,"column":0}},{"generated":{"line":7,"column":13},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":1,"column":0},"name":"require"},{"generated":{"line":7,"column":20},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":0},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":3,"column":0}},{"generated":{"line":8,"column":4},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":3,"column":6},"name":"CSMShader"},{"generated":{"line":8,"column":13},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":3,"column":15}},{"generated":{"line":8,"column":16},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":3,"column":15},"name":"exports"},{"generated":{"line":8,"column":23},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":3,"column":15}},{"generated":{"line":8,"column":24},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":3,"column":15},"name":"CSMShader"},{"generated":{"line":8,"column":33},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":3,"column":15}},{"generated":{"line":8,"column":36},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":3,"column":18}},{"generated":{"line":9,"column":2},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":4,"column":1},"name":"lights_fragment_begin"},{"generated":{"line":9,"column":23},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":4,"column":22}},{"generated":{"line":9,"column":25},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":4,"column":24}},{"generated":{"line":9,"column":10918},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":285,"column":1}},{"generated":{"line":10,"column":2},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":286,"column":1},"name":"lights_pars_begin"},{"generated":{"line":10,"column":19},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":286,"column":18}},{"generated":{"line":10,"column":21},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":286,"column":20}},{"generated":{"line":10,"column":31},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":286,"column":30}},{"generated":{"line":10,"column":194},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":292,"column":5},"name":"ShaderChunk"},{"generated":{"line":10,"column":212},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":292,"column":16}},{"generated":{"line":10,"column":213},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":292,"column":17},"name":"lights_pars_begin"},{"generated":{"line":11,"column":0},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":293,"column":0}},{"generated":{"line":11,"column":1},"source":"../node_modules/three/examples/jsm/csm/CSMShader.js","original":{"line":293,"column":1}}],"sources":{"../node_modules/three/examples/jsm/csm/CSMShader.js":"import { ShaderChunk } from 'three';\n\nconst CSMShader = {\n\tlights_fragment_begin: /* glsl */`\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometryClearcoatNormal = clearcoatNormal;\n\n#endif\n\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\t// Iridescence F0 approximation\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n \tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\n  \t\t// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\n\t\tvec2 cascade;\n\t\tfloat cascadeCenter;\n\t\tfloat closestEdge;\n\t\tfloat margin;\n\t\tfloat csmx;\n\t\tfloat csmy;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\t\t\t// NOTE: Depth gets larger away from the camera.\n\t\t\t\t// cascade.x is closer, cascade.y is further\n\t\t\t\tcascade = CSM_cascades[ i ];\n\t\t\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\n\t\t\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\n\t\t\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\n\t\t\t\tcsmx = cascade.x - margin / 2.0;\n\t\t\t\tcsmy = cascade.y + margin / 2.0;\n\t\t\t\tif( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\n\n\t\t\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\n\t\t\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\n\n\t\t\t\t\tvec3 prevColor = directLight.color;\n\t\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\n\t\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\n\n\t\t\t\t\tReflectedLight prevLight = reflectedLight;\n\t\t\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\n\t\t\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\n\n\t\t\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\n\t\t\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\n\t\t\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\n\t\t\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\n\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#elif defined (USE_SHADOWMAP)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )\n\t\t// note: no loop here - all CSM lights are in fact one light only\n\t\tgetDirectionalLightInfo( directionalLights[0], directLight );\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t#endif\n\n\t#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)\n\t\t// compute the lights not casting shadows (if any)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t#if defined( USE_LIGHT_PROBES )\n\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\n\t#endif\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n`,\n\tlights_pars_begin: /* glsl */`\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\nuniform vec2 CSM_cascades[CSM_CASCADES];\nuniform float cameraNear;\nuniform float shadowFar;\n#endif\n\t` + ShaderChunk.lights_pars_begin\n};\n\nexport { CSMShader };\n"},"lineCount":null}},"error":null,"hash":"f77230e35c7cdcf281b06ed1cba3bcdf","cacheData":{"env":{}}}